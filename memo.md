- [二章](#二章)
  - [br\_table めっちゃ読みづらそう…](#br_table-めっちゃ読みづらそう)
- [3章](#3章)
  - [table.js#64参照](#tablejs64参照)


https://github.com/battlelinegames/ArtOfWasm

コンパイルコマンドは、`npx wat-wasm filepath.wat`

# 二章
---
命名規則がよくわからない
- js にあわせたほうが良い気がする
- 書籍の中でもスネークケースか、キャメルケースか統一されてない

---
- helloworld.js の `({ helloworld: hello_world } = obj.instance.exports);`って書き方初めて見た
- ↑みたいな珍しい？高度な？書き方するくせに、`const`でいいところを`let`にしてたりする

---
- stack はおもったよりすんなりと理解できた
  - S式の展開も難しいとは感じなかった
  - まえにちょっとだけrevの勉強したときの記憶が残ってるせいかも
---

`local.set $sum`のときに、値をポップしてどこに格納しているのか気になった

- そこはwasm使う側の人は気にしなくていい部分？
- まえに出てきてた線形メモリってところではないと思う
  - まえに線形メモリを使ったときはもっと複雑な手続きが必要だった

---
`global.get`と`local.get`の違いがよくわかってない
どちらもスタック上に値を重ねるのでは？
js からも見えるのが global ということ？
ちがった、global, local というのは、変数についての属性で、グローバルなスタックとローカルなスタックがあるとかの話ではなかった

---
```wat
(global $start_string (import "env" "start_string") i32)
(global $string_len i32 (i32.const 12))
```
pdf p.40 の以下のコードもよくわからない
``````
global 変数名 値 型
global 変数名 型 値
``````

型と値の順番が違う？

---
> Memoryオブジェクトを 1 ページのサイズで初期化するために、コンストラクタの initial パラメータに 1 を渡しています。この方法で 2 ギガバイトまで確保できますが、この値を大きくしすぎると、Web ブラウザがその要求を満たすような連続メモリを見つけられない場合にエラーになることがあります　pdf p.41

この 2 GB までというのは、仕様で決められている部分？
メモリが連続していないといけない、というのは js で全然意識しない部分だから、低レイヤやってるという感じがする。
 
---
> 実際には、WAT の loop 式はひとりでにループしたりしません。loop 式の先頭に戻るには、ループの中に分岐文が含まれている必要があります。
> pdf p.57

分岐文が含まれている必要がある→br文が含まれている必要がある、じゃない？
それとも、br文のことを分岐文と呼んでる？と思ったら、そのとおりだった
> br 文（➋）はコード内の別の場所にジャンプすることをプログラムに命令する分岐文です
> pdf p.56

---
> Web ブラウザで実行するための WAT を記述するときには、無限ループは絶対に使わないでください。WebAssembly は Web ブラウザのレンダリングを行わないため、Web ブラウザに制御を戻す必要があります。WebAssembly が制御を戻さない場合、Web ブラウザは応答しなくなります。
> pdf p.58

wasm の処理もレンダリングをブロッキングするらしい。

---
`loop.wat`を眺めるかんじ、関数シグネチャでresultの型を指定すると、その型の分のデータをスタックからポップするっぽい。

---

block に br するとそのブロックの最後に飛ばされるというのは、大分慣れが必要そう。loop とは、そのブロックの先頭に戻るっていう考え方も、あんまりしっくりこなかった（考えればわかるけど）
他のアセンブリとかも、こういう感じでループを実装してるんだろうか？

---
br_table めっちゃ読みづらそう…
---

# 3章
---
wasmの関数の概要
- 組み込み環境由来の関数
  - import してモジュール内で使う
  - wasmモジュール由来の関数と比べて消費サイクルが多い
- wasmモジュール由来の関数
  - エクスポートして組み込み環境で使う方法
    - エクスポートのに最適な関数は、ループを使って大量のデータを処理するもの
  - モジュール内で使う方法
    - 関数を分けると、デバッグしやすくなるが、パフォーマンスに悪影響がある
    - 最適化を考えるなら、インライン化したほうが良い

---
wasm の bool 値
- wasm には bool 値が存在しない
- 0, 1 が JS では falsy, truthy として扱われることを利用して、真偽を表現する

---
コーディングしてるとき
- エディタの補完が貧弱
- 定義済みの関数とかは候補に出してほしい
- 定義してない変数を使ってたりしたらエディタがエラーを出してほしい

---
リスト3-6
- 4 行目のローカル変数 $i の定義はもっと後でも良さそうだけど、そういうお作法？
- $not_prime ブロックのなかの一度しか実行されない処理は、ブロックの外に出した方がみやすくなりそう

---
関数からスタックへのアクセス（p.55, リスト3-12）
[ch3/out_of_bounds.wat](./ch3/out_of_bounds.wat)

- 呼び出された関数は、呼び出し元でスタックに積まれた値にアクセスできない
  - 呼び出した関数に値を渡したい場合は、引数を使う
  - このような仕様になっているのはセキュリティ上の理由？
- 余分な値がスタックにあってもエラーになる
  - コード参照

---
インポートする関数（p.56）
- 組み込み環境由来の関数
- JS のコールバック関数
  - 引数は数値だけ（詳しくは第五章）
  - wasm の環境においてインポートした関数に渡せるのは、i32, f32, f64
    - i64 は渡せない
      - BigInt がサポートされれば変わる
      - 型変換をwasm側で行う必要がある

---
OOP について
- WAT ではサポートしてない
- C/C++のstruct のような方法でデータを扱うことはできる
  - 線形メモリを利用する
  - C/C++をつかったことがないのでわからない
    - だれか詳しい人に教えてもらう（JSのオブジェクトとの違いとか？）

---

外部関数の呼び出しがパフォーマンスに与える影響(p.58)
- WAT でインポートした JS の関数を呼び出すと計算サイクルが少し消費される
- 大量に呼び出すとパフォーマンスに悪影響
  - 400万回の呼び出し
  - Chrome では 4~8 倍
  - Firefox では 2~2.5倍
  - node v20.5.0 で試したところ、2倍くらい
    - コード参照

---
関数テーブル
- 関数だけが割り当てられるが、将来的には他のデータもサポートされる予定
  - anyfunc型（wasmの汎用関数型）をサポートしている
  - JSオブジェクトやDOM要素もサポートするかもしれない
- 実行時に動的に関数を入れ替えることができる
  - 関数ポインタ
  - OOPの仮想関数

- テーブルに追加できるのは、wasmモジュール内で定義された関数のみ
  - JSの関数は一度インポートする


---
```wat
(loop $dec_cycle
    call $wasm_decrement
    i32.const 4_000_000
    i32.le_u
    br_if $dec_cycle
)
```

このコードがうまく動くのは、`le_u`の挙動のせい
unsigned の前提で比較しているので、-1について4_000_000より大きいと判断する
table.js#64参照
---